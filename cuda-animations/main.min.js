const ppcStepV0Lines=["__global__ void kernel(float* r, const float* d, int n) {","    const int i = threadIdx.x + blockIdx.x * blockDim.x;","    const int j = threadIdx.y + blockIdx.y * blockDim.y;","    float v = HUGE_VALF;","    for (int k = 0; k < n; ++k) {","        float x = d[n*i + k];","        float y = d[n*k + j];","        float z = x + y;","        v = min(v, z);","    }","    r[n*i + j] = v;","}",];const ppcStepV0Statements=[function(){this.locals.i=this.arithmetic(this.threadIdx.x+this.blockIdx.x*this.blockDim.x);},function(){this.locals.j=this.arithmetic(this.threadIdx.y+this.blockIdx.y*this.blockDim.y);},function(){this.locals.v=this.identity(Infinity);},function(){this.locals.k=this.identity(0);},function(){this.locals.x=this.arrayGet(this.args.input,this.args.n*this.locals.i+this.locals.k);},function(){this.locals.y=this.arrayGet(this.args.input,this.args.n*this.locals.k+this.locals.j);},function(){this.locals.z=this.arithmetic(this.locals.x+this.locals.y);},function(){this.locals.v=this.arithmetic(Math.min(this.locals.v,this.locals.z));},function(){if(++this.locals.k<this.args.n){this.jump(-4);}},function(){this.identity(0);},];const ppcStepV1Lines=["__global__ void kernel(float* r, const float* d, int n) {","    const int i = threadIdx.x + blockIdx.x * blockDim.x;","    const int j = threadIdx.y + blockIdx.y * blockDim.y;","    float v = HUGE_VALF;","    for (int k = 0; k < n; ++k) {","        float x = d[n*j + k];","        float y = d[n*k + i];","        float z = x + y;","        v = min(v, z);","    }","    r[n*j + i] = v;","}",];const ppcStepV1Statements=[function(){this.locals.i=this.arithmetic(this.threadIdx.x+this.blockIdx.x*this.blockDim.x);},function(){this.locals.j=this.arithmetic(this.threadIdx.y+this.blockIdx.y*this.blockDim.y);},function(){this.locals.v=this.identity(Infinity);},function(){this.locals.k=this.identity(0);},function(){this.locals.x=this.arrayGet(this.args.input,this.args.n*this.locals.j+this.locals.k);},function(){this.locals.y=this.arrayGet(this.args.input,this.args.n*this.locals.k+this.locals.i);},function(){this.locals.z=this.arithmetic(this.locals.x+this.locals.y);},function(){this.locals.v=this.arithmetic(Math.min(this.locals.v,this.locals.z));},function(){if(++this.locals.k<this.args.n){this.jump(-4);}},function(){this.identity(0);},];const ppcStepV2Lines=["__global__ void kernel(float* r, const float* d, int n) {","    const int ia = threadIdx.x;","    const int ja = threadIdx.y;","    const int ic = blockIdx.x;","    const int jc = blockIdx.y;"," ","    const float* t = d + n * n;"," ","    float v[8]v[8];","    for (int ib = 0; ib < 8; ++ib) {","        for (int jb = 0; jb < 8; ++jb) {","            v[ib][jb] = HUGE_VALF;","        }","    }","    for (int k = 0; k < n; ++k) {","        float x[8];","        float y[8];","        for (int ib = 0; ib < 8; ++ib) {","            int i = ic * 64 + ib * 8 + ia;","            x[ib] = t[n*k + i];","        }","        for (int jb = 0; jb < 8; ++jb) {","            int j = jc * 64 + jb * 8 + ja;","            y[jb] = d[n*k + j];","        }","        for (int ib = 0; ib < 8; ++ib) {","            for (int jb = 0; jb < 8; ++jb) {","                v[ib][jb] = min(v[ib][jb], x[ib] + y[jb]);","            }","        }","    }","    for (int ib = 0; ib < 8; ++ib) {","        for (int jb = 0; jb < 8; ++jb) {","            int i = ic * 64 + ib * 8 + ia;","            int j = jc * 64 + jb * 8 + ja;","            r[n*i + j] = v[ib][jb];","        }","    }","}",];const ppcStepV2Statements=[function(){this.locals.ia=this.identity(this.threadIdx.x);},function(){this.locals.ja=this.identity(this.threadIdx.y);},function(){this.locals.ic=this.identity(this.blockIdx.x);},function(){this.locals.jc=this.identity(this.blockIdx.y);},function(){this.identity(null);},function(){this.locals.t={dOffset:this.identity(16)};},function(){this.identity(null);},function(){this.locals.v=this.identity(Array.from(new Array(8),_=>new Array(8)));},function(){const v=this.locals.v;for(let ib=0;ib<8;++ib){for(let jb=0;jb<8;++jb){v[ib][jb]=this.identity(Infinity);}}},function(){this.identity(null);},function(){this.identity(null);},function(){this.identity(null);},function(){this.identity(null);},function(){this.locals.k=this.identity(0);},function(){this.locals.x=this.identity(new Array(8));},function(){this.locals.y=this.identity(new Array(8));},function(){this.locals.ib=this.identity(0);},function(){const ia=this.locals.ia;const ib=this.locals.ib;const ic=this.locals.ic;this.locals.i=this.arithmetic(ic*64+ib*8+ia);},function(){const ib=this.locals.ib;const n=this.args.n;const k=this.locals.k;const i=this.locals.i;const x=this.locals.x;const tOffset=n*this.locals.t.dOffset;x[ib]=this.arrayGet(this.args.input,tOffset+n*k+i);},function(){if(++this.locals.ib<8){this.jump(-2);}else{this.locals.ib=undefined;}},function(){this.locals.jb=this.identity(0);},function(){const ja=this.locals.ja;const jb=this.locals.jb;const jc=this.locals.jc;this.locals.j=this.arithmetic(jc*64+jb*8+ja);},function(){const jb=this.locals.jb;const n=this.args.n;const k=this.locals.k;const j=this.locals.j;const y=this.locals.y;y[jb]=this.arrayGet(this.args.input,n*k+j);},function(){if(++this.locals.jb<8){this.jump(-2);}else{this.locals.jb=undefined;}},function(){this.identity(null);},function(){this.identity(null);},function(){this.identity(null);},function(){this.identity(null);},function(){this.identity(null);},function(){if(++this.locals.k<this.args.n&&this.locals.k<this.locals.t.dOffset){this.jump(-15);}else{this.locals.k=undefined;}},function(){this.identity(null);},function(){this.identity(null);},function(){this.identity(null);},function(){this.identity(null);},function(){this.identity(null);},function(){this.identity(null);},function(){this.identity(null);},];const CUDAKernels={ppcStepV0:{displayName:"Shortcut step v0",kernelArgs:{n:32,},memory:{input:{rows:32,columns:32,},},grid:{dimGrid:{x:2,y:2,},dimBlock:{x:16,y:16},},sourceLines:ppcStepV0Lines,statements:ppcStepV0Statements,sourceMessages:['Source: <a href="http://ppc.cs.aalto.fi/ch4/v0/">Baseline</a>'],},ppcStepV1:{displayName:"Shortcut step v1",kernelArgs:{n:32,},memory:{input:{rows:32,columns:32,},},grid:{dimGrid:{x:2,y:2,},dimBlock:{x:16,y:16},},sourceLines:ppcStepV1Lines,statements:ppcStepV1Statements,sourceMessages:['Source: <a href="http://ppc.cs.aalto.fi/ch4/v1/">Better memory access pattern</a>'],},ppcStepV2:{displayName:"Shortcut step v2",kernelArgs:{n:64,},memory:{input:{rows:32,columns:64,},extraRowPadding:{index:15,amount:4,},},grid:{dimGrid:{x:1,y:1,},dimBlock:{x:8,y:8},},sourceLines:ppcStepV2Lines,statements:ppcStepV2Statements,memoryMessages:["Showing only top 16 rows of d and t."],sourceMessages:['Source: <a href="http://ppc.cs.aalto.fi/ch4/v2/">Reuse in data registers</a>'],},};for(let kernel in CUDAKernels){if(typeof CUDAKernels[kernel].sourceMessages==="undefined"){CUDAKernels[kernel].sourceMessages=[];}
CUDAKernels[kernel].sourceMessages.push("For simplicity, assume each kernel line maps one-to-one into compiled SASS assembly. Also assume all threads in a single warp execute their instructions simultaneously.");}"use strict";function failHard(){drawing=false;const errorBanner=document.getElementById("body-error-banner");errorBanner.innerHTML="Something went wrong, please see the developer console";errorBanner.hidden=false;cancelDraw();}
function assert(expr,msg,state){if(!expr){failHard();console.error("ASSERTION FAILED");if(typeof state!=="undefined"){console.error(state.name+" was:");printobj(state.obj);}
throw"AssertionError: "+msg;}}
function printobj(o){console.log(JSON.stringify(o,null,2));}
function dumpCachelines(o){for(let[index,line]of o.entries()){console.log("index",index,"width",line.lineSize);console.log("  "+Array.from(line.indexes).join(' '));}}
function disjoint(set1,set2){for(let x of set1.values())
if(set2.has(x))
return false;return true;}
function get4Palette(key){let alpha=0.2;let palette=[];switch(key){case"rgba-colorful":palette=[[35,196,1,alpha],[227,1,23,alpha],[235,190,2,alpha],[47,21,182,alpha],];break;case"rgba-grayscale":alpha=0.5;palette=[[100,100,100,alpha],[200,200,200,alpha],[0,0,0,alpha],[50,50,50,alpha],];break;default:failHard();console.error("unknown palette key: "+key);}
return palette;}
const CONFIG={animation:{SMColorPalette:get4Palette("rgba-colorful"),},latencies:{none:{name:"No",arithmetic:0,L2CacheAccess:0,memoryAccess:0,},veryLow:{name:"Very low",arithmetic:0,L2CacheAccess:0,memoryAccess:2,},low:{name:"Low",arithmetic:1,L2CacheAccess:5,memoryAccess:15,},reduced:{name:"Reduced",arithmetic:2,L2CacheAccess:25,memoryAccess:75,},realistic:{name:"Realistic",arithmetic:15,L2CacheAccess:60,memoryAccess:600,},},memory:{slotPadding:1,slotSizes:{min:8,max:20,step:4,},slotFillRGBA:[160,160,160,0.2],coolDownPeriod:20,},cache:{L2CacheLineSize:8,L2CacheLines:40,cachedStateRGBA:[160,160,160,0.6],},SM:{count:{min:1,max:4,},warpSize:32,warpSchedulers:1,latencyNoiseProb:0.05,},};class Drawable{constructor(label,x,y,width,height,canvas,strokeRGBA,fillRGBA){this.label=label;this.x=x;this.y=y;this.width=width;this.height=height;this.canvasContext=canvas.getContext("2d");this.strokeRGBA=(typeof strokeRGBA==="undefined")?null:strokeRGBA.slice();this.fillRGBA=(typeof fillRGBA==="undefined")?null:fillRGBA.slice();}
draw(){const x=this.x;const y=this.y;const width=this.width;const height=this.height;const ctx=this.canvasContext;if(this.fillRGBA!==null){ctx.fillStyle="rgba("+this.fillRGBA.join(',')+')';ctx.fillRect(x,y,width,height);}
if(this.strokeRGBA!==null){ctx.strokeStyle="rgba("+this.strokeRGBA.join(',')+')';ctx.strokeRect(x,y,width,height);}}}
class L2Cache{constructor(linesCount){this.lines=new Array(linesCount);this.ages=new Array(linesCount);this.clear();this.lineSize=CONFIG.cache.L2CacheLineSize;this.memoryAccessQueue=new Map;this.cacheAccessQueue=new Map;}
align(i){return i-i%this.lineSize;}*allQueuedInstructions(){yield*this.memoryAccessQueue.values();yield*this.cacheAccessQueue.values();}
coalesceMemoryTransactions(instructions){let cacheLines32=new Map;for(let instruction of instructions){const index=instruction.data.index;const aligned32=index-index%8;const line32=cacheLines32.get(aligned32);if(typeof line32!=="undefined"){line32.indexes.add(index);line32.lineSize=8;}else{cacheLines32.set(aligned32,{indexes:new Set([index]),lineSize:8});}}
let cacheLines64=new Map;for(let[aligned32,line32]of cacheLines32.entries()){const aligned64=aligned32-aligned32%16;if(cacheLines64.has(aligned64)){continue;}
const line32left=cacheLines32.get(aligned64);if(typeof line32left==="undefined"||!disjoint(line32.indexes,line32left.indexes)){cacheLines64.set(aligned32,line32);}else{const lineIndexes=new Set;for(let index of line32.indexes){lineIndexes.add(index);}
for(let index of line32left.indexes){lineIndexes.add(index);}
cacheLines64.set(aligned64,{indexes:lineIndexes,lineSize:16});}}
let cacheLines128=new Map;for(let[aligned64,line64]of cacheLines64.entries()){const aligned128=aligned64-aligned64%32;if(cacheLines128.has(aligned128)){continue;}
const line64left=cacheLines64.get(aligned128);if(typeof line64left==="undefined"||!disjoint(line64.indexes,line64left.indexes)){cacheLines128.set(aligned64,line64);}else{const lineIndexes=new Set;for(let index of line64.indexes){lineIndexes.add(index);}
for(let index of line64left.indexes){lineIndexes.add(index);}
cacheLines128.set(aligned128,{indexes:lineIndexes,lineSize:32});}}
return cacheLines128;}
coalesceAndMergeCacheLines(){const instructions=Array.from(this.memoryAccessQueue.values(),instructions=>instructions[0])
const unCoalesced=instructions.filter(instruction=>{return!instruction.data.coalesced;});if(unCoalesced.length===0){return;}
const newCacheLines=this.coalesceMemoryTransactions(unCoalesced);const coalescedLatency=newCacheLines.size*unCoalesced[0].cyclesLeft;for(let[index,line]of newCacheLines.entries()){for(let i=index;i<index+line.lineSize;++i){if(!this.memoryAccessQueue.has(i)){this.memoryAccessQueue.set(i,new Array);}
let queued=this.memoryAccessQueue.get(i);queued.push(Instruction.deviceMemoryAccess(i));for(let instruction of queued){instruction.setLatency(coalescedLatency);instruction.data.coalesced=true;}}}}
updateCacheLines(){let completedInstructions=new Array;for(const[index,instructions]of this.memoryAccessQueue.entries()){for(let instruction of instructions){if(instruction.isDone()){const memoryIndex=instruction.data.index;const lineIndex=this.getCachedIndex(index);if(lineIndex<0){this.addNew(index);}else{if(this.ages.length>0){this.ages[lineIndex]=0;}}
completedInstructions.push(instruction);}}}
return completedInstructions;}
step(){let completedInstructions=this.updateCacheLines();for(const instructions of this.cacheAccessQueue.values()){for(const instruction of instructions){if(instruction.isDone()){completedInstructions.push(instruction);}}}
for(let instruction of completedInstructions){if(instruction.name.startsWith("device")){this.memoryAccessQueue.delete(instruction.data.index);}else{this.cacheAccessQueue.delete(instruction.data.index);}}
this.coalesceAndMergeCacheLines()
for(const instructions of this.allQueuedInstructions()){for(const instruction of instructions){instruction.cycle();}}
for(let i=0;i<this.ages.length;++i){++this.ages[i];}
return completedInstructions.filter(instruction=>{const SM_ID=instruction.data.SM_ID;return typeof SM_ID!=="undefined";});}
getCachedIndex(i){const aligned=this.align(i)+1;return this.lines.findIndex(cached=>cached>0&&aligned===cached);}
addLine(i,j){this.lines[i]=this.align(j)+1;this.ages[i]=0;}
addNew(i){if(this.lines.length===0){return;}
const oldestIndex=this.lines.reduce((oldest,_,index)=>{if((this.ages[index]>this.ages[oldest])||(this.ages[index]===this.ages[oldest]&&index<oldest)){return index;}else{return oldest;}},0);this.addLine(oldestIndex,i);}
queueMemoryAccess(i,SM_ID){let newInstruction=Instruction.deviceMemoryAccess(i,SM_ID);if(!this.memoryAccessQueue.has(i)||this.memoryAccessQueue.get(i).every(instruction=>instruction.isDone())){this.memoryAccessQueue.set(i,new Array);}else{const oldestInstruction=this.memoryAccessQueue.get(i)[0];newInstruction.setLatency(oldestInstruction.cyclesLeft);}
this.memoryAccessQueue.get(i).push(newInstruction);return newInstruction;}
queueCacheAccess(i,SM_ID){let newInstruction=Instruction.cachedMemoryAccess(i,SM_ID);if(!this.cacheAccessQueue.has(i)||this.cacheAccessQueue.get(i).every(instruction=>instruction.isDone())){this.cacheAccessQueue.set(i,new Array);}else{const oldestInstruction=this.cacheAccessQueue.get(i)[0];newInstruction.setLatency(oldestInstruction.cyclesLeft);}
this.cacheAccessQueue.get(i).push(newInstruction);return newInstruction;}
fetch(SM_ID,i){let fetchInstruction;const j=this.getCachedIndex(i);if(j<0){fetchInstruction=this.queueMemoryAccess(i,SM_ID);}else{this.ages[j]=0;fetchInstruction=this.queueCacheAccess(i,SM_ID);}
return fetchInstruction;}
getCacheState(i){if(this.getCachedIndex(i)>=0){return{type:"cached",completeRatio:1.0};}
let queuedInstructions=this.memoryAccessQueue.get(i);if(typeof queuedInstructions!=="undefined"){let queuedInstruction=queuedInstructions[0];return{type:"pendingMemoryAccess",completeRatio:queuedInstruction.completeRatio};}
return{type:"notInCache",completeRatio:0.0};}
clear(){this.lines.fill(0);this.ages.fill(0);}}
class CUDAKernelContext{constructor(SM_ID){this.locals={};this.args={};this.threadIdx={x:null,y:null,};this.blockIdx={x:null,y:null,};this.blockDim={x:null,y:null,};this.prevInstruction=null;this.SM_ID=SM_ID;}
identity(x){this.prevInstruction=Instruction.identity();return x;}
arithmetic(result){this.prevInstruction=Instruction.arithmetic();return result;}
arrayGet(memoryGetHandle,index){this.prevInstruction=memoryGetHandle(index,false,undefined,this.SM_ID);return memoryGetHandle(index,true);}
arraySet(memorySetHandle,index,value){this.prevInstruction=memorySetHandle(index,false,value);memorySetHandle(index,true,value);}
jump(offset){this.prevInstruction=Instruction.jump(offset);}}
class DeviceMemory extends Drawable{constructor(x,y,canvas,inputDim,slotSize,extraPadding){const rows=inputDim.rows;const columns=inputDim.columns;const slotPadding=CONFIG.memory.slotPadding;const width=columns*slotSize+slotPadding*columns;let height=rows*slotSize+slotPadding*rows;if(typeof extraPadding!=="undefined"){height+=extraPadding.amount-slotPadding;}
super("device-memory",x,y,width,height,canvas);const slotFillRGBA=CONFIG.memory.slotFillRGBA.slice();this.slots=Array.from(new Array(columns*rows),(_,i)=>{const slotX=x+(i%columns)*(slotSize+slotPadding);const rowIndex=Math.floor(i/columns);let slotY=y+rowIndex*(slotSize+slotPadding);if(typeof extraPadding!=="undefined"&&extraPadding.index<rowIndex){slotY+=extraPadding.amount;}
const memorySlot=new MemorySlot(i,2,"memory-slot",slotX,slotY,slotSize,slotSize,canvas,undefined,slotFillRGBA);const overlays=Array.from(CONFIG.animation.SMColorPalette,SM_color=>{const coolDownPeriod=CONFIG.memory.coolDownPeriod;const coolDownStep=(1.0-SM_color[3])/(coolDownPeriod+1);return{drawable:new Drawable("memory-slot-overlay-SM-color",slotX,slotY,slotSize,slotSize,canvas,undefined,SM_color),defaultColor:SM_color.slice(),hotness:0,coolDownPeriod:coolDownPeriod,coolDownStep:coolDownStep,};});let threadAccessCounter=new Array(CONFIG.SM.count.max);threadAccessCounter.fill(0);return{memory:memorySlot,overlays:overlays,threadAccessCounter:threadAccessCounter,};});}
touch(SM_ID,memoryIndex){const slot=this.slots[memoryIndex];++slot.threadAccessCounter[SM_ID-1];let overlay=slot.overlays[SM_ID-1];overlay.hotness=overlay.coolDownPeriod;overlay.drawable.fillRGBA[3]=0.6;}
untouch(SM_ID,memoryIndex){const queue=this.slots[memoryIndex].threadAccessCounter;if(queue[SM_ID-1]>0){--queue[SM_ID-1];}}
step(getCacheState){for(let[i,slot]of this.slots.entries()){slot.memory.setCachedState(getCacheState(i));slot.memory.draw();}
this.draw();}*SMsCurrentlyAccessing(slot){const counter=slot.threadAccessCounter;for(let SM_ID=1;SM_ID<counter.length+1;++SM_ID){if(counter[SM_ID-1]>0){yield SM_ID;}}}
numSMsCurrentlyAccessing(slot){return Array.from(this.SMsCurrentlyAccessing(slot)).length;}
draw(){for(let[i,slot]of this.slots.entries()){let SM_count=0;const numSMs=this.numSMsCurrentlyAccessing(slot);for(let SM_ID=1;SM_ID<slot.overlays.length+1;++SM_ID){let overlay=slot.overlays[SM_ID-1];const drawable=overlay.drawable;if(slot.threadAccessCounter[SM_ID-1]>0){SM_count++;const originalX=drawable.x;const originalWidth=drawable.width;drawable.x+=(numSMs-SM_count)*originalWidth/numSMs;drawable.width/=numSMs;drawable.draw();drawable.x=originalX;drawable.width=originalWidth;if(overlay.hotness>overlay.coolDownPeriod/2){--overlay.hotness;overlay.drawable.fillRGBA[3]-=overlay.coolDownStep;}}else{if(overlay.hotness>0){--overlay.hotness;drawable.draw();}
if(overlay.hotness===0){overlay.drawable.fillRGBA[3]=0;}else{overlay.drawable.fillRGBA[3]-=overlay.coolDownStep;}}}}
super.draw();}
clear(){for(let slot of this.slots){slot.memory.clear();slot.threadAccessCounter.fill(0);slot.overlays.forEach(o=>o.hotness=0);}}}
class MemorySlot extends Drawable{constructor(index,value,...drawableArgs){super(...drawableArgs);this.index=index;this.value=value;this.defaultColor=this.fillRGBA.slice();this.cachedColor=CONFIG.cache.cachedStateRGBA.slice();}
setCachedState(state){if(state.type==="pendingMemoryAccess"){this.fillRGBA=this.defaultColor;this.progressRGBA=this.cachedColor;this.progressRatio=state.completeRatio;}else{this.progressRGBA=null;this.progressRatio=null;}
if(state.type==="cached"){this.fillRGBA=this.cachedColor;}else if(state.type==="notInCache"){this.fillRGBA=this.defaultColor;}}
draw(){super.draw();const x=this.x;const y=this.y;const width=this.width;const height=this.height;const ctx=this.canvasContext;if(this.progressRGBA!==null){ctx.fillStyle="rgba("+this.progressRGBA.join(',')+')';const yOffset=(1.0-this.progressRatio)*height;ctx.fillRect(x,y+yOffset,width,height-yOffset);}}
clear(){this.fillRGBA=this.defaultColor.slice();}}
class Grid{constructor(dimGrid,dimBlock){this.dimGrid=dimGrid;this.dimBlock=dimBlock;this.blocks=Array.from(new Array(dimGrid.x*dimGrid.y),(_,i)=>{const x=i%dimGrid.x;const y=Math.floor(i/dimGrid.x);return new Block({x:x,y:y},dimBlock);});}
nextFreeBlockIndex(){return this.blocks.findIndex(block=>!block.locked&&!block.processed);}}
class Block{constructor(blockIdx,dimBlock){this.locked=false;this.processed=false;this.dim=dimBlock;this.idx=blockIdx;}*asWarps(kernelArgs,SM_ID){const warpSize=CONFIG.SM.warpSize;const threadCount=this.dim.x*this.dim.y;let threadIndexes=new Array;for(let j=0;j<this.dim.y;++j){for(let i=0;i<this.dim.x;++i){threadIndexes.push({x:i,y:j});if(threadIndexes.length===warpSize){const warp=new Warp(this,threadIndexes.slice(),kernelArgs,SM_ID);threadIndexes=new Array;yield warp;}}}}}
class Thread{constructor(threadIdx){this.idx=threadIdx;this.isMasked=false;this.statement=null;this.kernelContext=null;this.instruction=Instruction.empty();this.prevInstruction=Instruction.empty();}
isActive(){return this.instruction.isDone();}
cycle(){if(this.isMasked){return;}
if(this.statement!==null){try{this.statement.apply(this.kernelContext);}catch(error){console.error("ERROR: while applying kernel context",this.kernelContext,"to statement",this.statement);console.error(error);failHard();}
this.prevInstruction=this.instruction;this.instruction=this.kernelContext.prevInstruction;this.statement=null;}else{this.prevInstruction=null;if(this.instruction.name!=="deviceMemoryAccess"){this.instruction.cycle();}}}}
class Warp{constructor(block,threadIndexes,kernelArgs,SM_ID){this.terminated=false;this.running=false;this.threads=Array.from(threadIndexes,idx=>new Thread(idx));this.initCUDAKernelContext(block,kernelArgs,SM_ID);this.programCounter=0;}
isActive(){return this.threads.every(t=>t.isActive());}
initCUDAKernelContext(block,kernelArgs,SM_ID){const warpContext={blockIdx:block.idx,blockDim:block.dim,args:Object.assign({},kernelArgs),};for(let t of this.threads){const threadContext={threadIdx:t.idx,};t.kernelContext=Object.assign(new CUDAKernelContext(SM_ID),warpContext,threadContext);}}
nextStatement(statement){this.threads.forEach(t=>t.statement=statement);++this.programCounter;}*changedThreadInstructions(){for(let thread of this.threads){if(thread.prevInstruction!==null){yield[thread.prevInstruction,thread.instruction];}}}
cycle(){this.threads.forEach(t=>t.cycle());const instr=this.threads[0].instruction;if(instr!==null&&!instr.isDone()){if(instr.name==="jump"){this.programCounter+=instr.data.jumpOffset+Math.sign(instr.data.jumpOffset);}}
if(instr.cyclesLeft<0){this.threads.forEach(t=>t.instruction.cyclesLeft=0);return false;}
return true;}}
class Instruction{constructor(name,latency,data){this.name=name;this.data=data||{};this.cyclesLeft=null;this.completeRatio=null;this.completeRatioStep=null;this.setLatency(latency);}
isDone(){return this.cyclesLeft===0;}
cycle(){if(this.cyclesLeft>0){--this.cyclesLeft;if(this.cyclesLeft===0){this.completeRatio=1.0;}else{this.completeRatio+=this.completeRatioStep;}}}
setLatency(latency){this.cyclesLeft=latency||0;this.maxCycles=this.cyclesLeft;if(this.maxCycles>0){this.completeRatio=0.0;this.completeRatioStep=1.0/this.maxCycles;}else{this.completeRatio=1.0;this.completeRatioStep=0.0;}}
static empty(){return new Instruction("empty",0);}
static identity(){return new Instruction("identity",-1);}
static jump(offset){return new Instruction("jump",-1,{jumpOffset:offset});}
static arithmetic(){return new Instruction("arithmetic",CONFIG.latencies[instructionLatencies].arithmetic);}
static cachedMemoryAccess(i,SM_ID){return new Instruction("cachedMemoryAccess",CONFIG.latencies[instructionLatencies].L2CacheAccess,{index:i,SM_ID:SM_ID});}
static deviceMemoryAccess(i,SM_ID){return new Instruction("deviceMemoryAccess",CONFIG.latencies[instructionLatencies].memoryAccess,{index:i,SM_ID:SM_ID});}}
class SMstats{constructor(SM_ID){this.stateElement=document.getElementById("sm-state-"+SM_ID);this.cycleCounter=this.stateElement.querySelector("ul li pre span.sm-cycle-counter");this.blockIdxSpan=this.stateElement.querySelector("ul li pre span.sm-current-block-idx");this.cycles=0;this.setColor(CONFIG.animation.SMColorPalette[SM_ID-1]);}
cycle(){++this.cycles;this.cycleCounter.innerHTML=this.cycles;}
setActiveBlock(block){this.blockIdxSpan.innerHTML=block?"(x: "+block.idx.x+", y:"+block.idx.y+")":'&ltnone&gt';}
terminate(){this.setColor([200,200,200,0.25]);this.setActiveBlock(null);}
setColor(color){this.stateElement.style.backgroundColor="rgba("+color.join(',')+')';}}
class SMController{constructor(SM_ID){this.schedulerCount=CONFIG.SM.warpSchedulers;this.residentWarps=new Array;this.grid=null;this.program=null;this.activeBlock=null;this.kernelArgs=null;this.statsWidget=new SMstats(SM_ID);this.SM_ID=SM_ID;this.completedInstructions=new Array;this.scheduledInstructions=new Array;}
scheduleNextBlock(){const i=this.grid.nextFreeBlockIndex();if(i<0){return false;}
const newBlock=this.grid.blocks[i];this.activeBlock=newBlock;this.activeBlock.locked=true;this.residentWarps=Array.from(this.activeBlock.asWarps(this.kernelArgs,this.SM_ID));this.statsWidget.setActiveBlock(this.activeBlock);return true;}
releaseProcessedBlock(){if(this.activeBlock!==null){this.activeBlock.locked=false;this.activeBlock.processed=true;this.activeBlock=null;}}*nonTerminatedWarps(){for(let warp of this.residentWarps)
if(!warp.terminated)
yield warp;}*activeWarps(){for(let warp of this.nonTerminatedWarps())
if(warp.isActive())
yield warp;}*freeWarps(){for(let warp of this.activeWarps())
if(!warp.running)
yield warp;}*scheduledWarps(){for(let warp of this.nonTerminatedWarps())
if(warp.running)
yield warp;}*blockingWarps(){for(let warp of this.scheduledWarps())
if(!warp.isActive())
yield warp;}
nextFreeWarp(){return this.freeWarps().next().value;}
nextBlockingWarp(){return this.blockingWarps().next().value;}
hasNonTerminatedWarps(){return!this.nonTerminatedWarps().next().done;}
generatorLength(generator){let count=0;for(let _ of generator){++count;}
return count;}
scheduledWarpsCount(){return this.generatorLength(this.scheduledWarps());}
activeWarpsCount(){return this.generatorLength(this.activeWarps());}
scheduleWarps(){while(this.scheduledWarpsCount()<this.schedulerCount){const freeWarp=this.nextFreeWarp();if(freeWarp){freeWarp.running=true;continue;}else{const blockingWarp=this.nextBlockingWarp();if(blockingWarp){blockingWarp.running=false;continue;}}
break;}}
updateProgramCounters(){for(let warp of this.scheduledWarps()){if(!warp.isActive()){continue;}
const warpPC=warp.programCounter;const statements=this.program.statements;if(warpPC<statements.length){warp.nextStatement(statements[warpPC]);}else{warp.terminated=true;}}}
cycle(){this.statsWidget.cycle();this.scheduleWarps();let isDone=true;if(this.hasNonTerminatedWarps()){this.updateProgramCounters();for(let warp of this.nonTerminatedWarps()){if(!warp.cycle()&&isDone){isDone=false;}
for(let[completed,scheduled]of warp.changedThreadInstructions()){this.completedInstructions.push(completed);this.scheduledInstructions.push(scheduled);}}}else{this.releaseProcessedBlock();const hasWork=this.scheduleNextBlock();if(!hasWork){this.program=null;}}
return isDone;}}
class StreamingMultiprocessor{constructor(SM_ID){this.controller=new SMController(SM_ID);}
cycle(){if(this.controller.program!==null){this.controller.cycle();}}*completedMemoryInstructions(){for(let instruction of this.controller.completedInstructions){if(instruction.name.endsWith("MemoryAccess")){yield instruction;}}
this.controller.completedInstructions=new Array;}*scheduledMemoryInstructions(){for(let instruction of this.controller.scheduledInstructions){if(instruction.name.endsWith("MemoryAccess")){yield instruction;}}
this.controller.scheduledInstructions=new Array;}
step(){if(Math.random()<CONFIG.SM.latencyNoiseProb){return;}
this.cycle();}
get_ID(){return this.controller.SM_ID;}}
class Device{constructor(memoryCanvas,smCount,cacheLines,input,memorySlotSize,extraPadding){this.memory=new DeviceMemory(0,0,memoryCanvas,input,memorySlotSize,extraPadding);this.multiprocessors=this.createProcessors(smCount);this.kernelSource=null;this.L2Cache=new L2Cache(cacheLines);this.kernelHighlightingOn=true;}
setProgram(grid,program){this.kernelSource=new KernelSource(program.sourceLines,program.sourceLineHeight);this.multiprocessors.forEach(sm=>{sm.controller.kernelArgs=Object.assign({},program.kernelArgs);sm.controller.program=program;sm.controller.grid=grid;sm.controller.scheduleNextBlock();});}
setKernelHighlighting(on){this.kernelHighlightingOn=on;}
programTerminated(){return this.multiprocessors.every(sm=>sm.controller.program===null);}
createProcessors(count){return Array.from(new Array(count),(_,i)=>new StreamingMultiprocessor(i+1));}
memoryTransaction(type,i,noSimulation,newValue,SM_ID){if(typeof noSimulation!=="undefined"&&noSimulation){if(type==="get"){return this.memory.slots[i].memory.value;}else if(type==="set"){this.memory.slots[i].memory.value=newValue;}}else{if(type==="get"||type==="set"){return this.L2Cache.fetch(SM_ID,i);}}}
step(){let completedMemoryInstructions=new Array;let scheduledMemoryInstructions=new Array;for(let sm of this.multiprocessors){sm.step();for(let instruction of sm.completedMemoryInstructions()){completedMemoryInstructions.push(instruction);}
for(let instruction of sm.scheduledMemoryInstructions()){scheduledMemoryInstructions.push(instruction);}
for(let warp of sm.controller.nonTerminatedWarps()){const lineno=warp.programCounter;if(this.kernelHighlightingOn&&lineno>0){this.kernelSource.setHighlight(sm.get_ID()-1,lineno);}}}
this.kernelSource.step();this.L2Cache.step();const L2CacheStateHandle=this.L2Cache.getCacheState.bind(this.L2Cache);for(let instruction of scheduledMemoryInstructions){this.memory.touch(instruction.data.SM_ID,instruction.data.index);}
this.memory.step(L2CacheStateHandle);for(let instruction of completedMemoryInstructions){this.memory.untouch(instruction.data.SM_ID,instruction.data.index);}}
clear(){this.memory.clear();this.multiprocessors.forEach(sm=>sm.controller.statsWidget.terminate());}}
class KernelSource{constructor(sourceLines,lineHeight){const palette=CONFIG.animation.SMColorPalette;this.highlightedLines=Array.from(sourceLines,(line,lineno)=>{const x=0;const y=lineno*lineHeight;const width=kernelCanvas.width;return{queue:new Array,colors:Array.from(palette,color=>{let hlColor=color.slice();hlColor[3]*=0.5;return{drawable:new Drawable("kernel-source-line-highlighting",x,y,width,lineHeight,kernelCanvas,undefined,hlColor),};}),};});}
setHighlight(colorIndex,lineno){this.highlightedLines[lineno].queue.push(colorIndex);}
drawHighlighted(){this.highlightedLines.forEach(line=>{const stackedColorCount=line.queue.length;if(stackedColorCount===0){return;}
line.queue.forEach((colorIndex,queueIndex)=>{const drawable=line.colors[colorIndex].drawable;const originalY=drawable.y;const originalHeight=drawable.height;drawable.y+=(stackedColorCount-queueIndex-1)*originalHeight/stackedColorCount
drawable.height/=stackedColorCount;drawable.draw();drawable.y=originalY;drawable.height=originalHeight;});line.queue=new Array;});}
step(){this.drawHighlighted();}}"use strict";var memoryCanvasInput;var kernelCanvas;var device;var drawing=true;var prevRenderFrameID;var activeKernel="ppcStepV1";var smCount=2;var cacheLineCount=CONFIG.cache.L2CacheLines;var instructionLatencies="low";var highlightKernelLines="on";var memorySlotSize=16;function makeSMlistBody(count){function liWrap(s,liID){if(typeof liID==="undefined"){return"<li>"+s+"</li>";}else{return"<li id=\"sm-state-"+liID+"\">"+s+"</li>";}}
function SMcontentsToUL(body){return"<ul>"+Array.from(body,li=>liWrap(li)).join("\n")+"</ul>";}
const defaultSMstateBody=['<pre>cycle <span class="sm-cycle-counter">0</span></pre>','<pre>block <span class="sm-current-block-idx">&ltnone&gt</span></pre>',];const liElements=Array.from(new Array(count),(_,i)=>{return liWrap(SMcontentsToUL(defaultSMstateBody),i+1);});return liElements.join("\n");}
function makeKernelSelectOptionsHTML(kernels){function makeOption(key){return"<option value=\""+key+"\">CUDA kernel: "+kernels[key].displayName+"</option>";}
const kernelsNoDefault=Object.keys(kernels).filter(k=>k!==activeKernel);const optionsHTML=Array.from([activeKernel].concat(kernelsNoDefault),makeOption);return optionsHTML.join("\n");}
function makeSMCountSelectOptionsHTML(config){function makeOption(key){return'<option value="'+key+'"'+((key===smCount)?'selected':'')+'>'+key+' SM'+((key>1)?'s':'')+'</option>';}
let optionsHTML=Array.from(new Array(config.max-config.min+1),(_,i)=>makeOption(i+config.min));return optionsHTML.join("\n");}
function makeCacheSizeSelectOptionsHTML(config){function makeOption(key){return'<option value="'+key+'"'+((key===cacheLineCount)?'selected':'')+'>Cache '+((key>0)?'enabled':'disabled')+'</option>';}
let optionsHTML=[makeOption(0),makeOption(CONFIG.cache.L2CacheLines),];return optionsHTML.join("\n");}
function makeLatencySelectOptionsHTML(){function makeOption(key){return'<option value="'+key+'"'+((key===instructionLatencies)?'selected':'')+'>'+CONFIG.latencies[key].name+' latency</option>';}
return Array.from(Object.keys(CONFIG.latencies),makeOption).join("\n");}
function makeHighlightSelectOptionsHTML(){function makeOption(key){return'<option value="'+key+'"'+((key===highlightKernelLines)?'selected':'')+'>Highlighted kernel lines '+key+' </option>';}
return[makeOption("on"),makeOption("off")].join("\n");}
function makeMemorySlotSizeSelectOptionsHTML(config){function makeOption(key){return'<option value="'+key+'"'+((key===memorySlotSize)?'selected':'')+'>DRAM slot size '+key+'</option>';}
const options=[];for(let size=config.min;size<=config.max;size+=config.step){options.push(makeOption(size));}
return options.join("\n");}
function parseStyle(style,prop,unit){if(typeof unit==="undefined"){unit="px";}
return parseFloat(style.getPropertyValue(prop).split(unit)[0]);}
function resetSizeAttrsFromStyle(element){const style=window.getComputedStyle(element,null);element.width=parseStyle(style,"width");element.height=parseStyle(style,"height");}
function resetSizeFromElement(source,target){const style=window.getComputedStyle(source,null);target.width=Math.ceil(parseStyle(style,"width"));target.height=Math.ceil(parseStyle(style,"height"));target.style.width=target.width.toString()+"px";target.style.height=target.height.toString()+"px";}
function resetSize(element,newWidth,newHeight){element.width=newWidth;element.height=newHeight;element.style.width=element.width.toString()+"px";element.style.height=element.height.toString()+"px";}
function initUI(){const pauseButton=document.getElementById("pause-button");const restartButton=document.getElementById("restart-button");const kernelSelect=document.getElementById("kernel-select");const smCountSelect=document.getElementById("sm-count-select");const cacheSizeSelect=document.getElementById("cache-size-select");const latencySelect=document.getElementById("latency-select");const highlightSelect=document.getElementById("highlight-select");const memorySlotSizeSelect=document.getElementById("memory-slot-size-select");pauseButton.addEventListener("click",_=>{pause();pauseButton.value=drawing?"Pause":"Continue";});restartButton.addEventListener("click",_=>{pauseButton.value="Pause";restart();});kernelSelect.addEventListener("change",event=>{drawing=false;activeKernel=event.target.value;pauseButton.value="Pause";restart();});smCountSelect.addEventListener("change",event=>{drawing=false;smCount=parseInt(event.target.value);pauseButton.value="Pause";restart();});cacheSizeSelect.addEventListener("change",event=>{drawing=false;cacheLineCount=parseInt(event.target.value);pauseButton.value="Pause";restart();});latencySelect.addEventListener("change",event=>{drawing=false;instructionLatencies=event.target.value;pauseButton.value="Pause";restart();});highlightSelect.addEventListener("change",event=>{highlightKernelLines=event.target.value;device.setKernelHighlighting(highlightKernelLines==="on");clear(kernelCanvas,"hard");});memorySlotSizeSelect.addEventListener("change",event=>{drawing=false;memorySlotSize=parseInt(event.target.value);pauseButton.value="Pause";restart();});}
function populateUI(){document.getElementById("sm-list").innerHTML=makeSMlistBody(smCount);document.getElementById("kernel-select").innerHTML=makeKernelSelectOptionsHTML(CUDAKernels);document.getElementById("sm-count-select").innerHTML=makeSMCountSelectOptionsHTML(CONFIG.SM.count);document.getElementById("cache-size-select").innerHTML=makeCacheSizeSelectOptionsHTML(CONFIG.cache.L2CacheLines);document.getElementById("latency-select").innerHTML=makeLatencySelectOptionsHTML();document.getElementById("highlight-select").innerHTML=makeHighlightSelectOptionsHTML();document.getElementById("memory-slot-size-select").innerHTML=makeMemorySlotSizeSelectOptionsHTML(CONFIG.memory.slotSizes);}
function initSimulation(){populateUI();memoryCanvasInput=document.getElementById("memoryCanvasInput");kernelCanvas=document.getElementById("kernelCanvas");const kernel=CUDAKernels[activeKernel];const kernelSource=document.getElementById("kernelSource");kernelSource.innerText=kernel.sourceLines.join('\n');resetSizeFromElement(kernelSource,kernelCanvas);const sourceStyle=window.getComputedStyle(kernelSource,null);const sourceLineHeight=parseStyle(sourceStyle,"line-height","em");device=new Device(memoryCanvasInput,smCount,cacheLineCount,kernel.memory.input,memorySlotSize,kernel.memory.extraRowPadding);const grid=new Grid(kernel.grid.dimGrid,kernel.grid.dimBlock);const kernelArgs=Object.assign(kernel.kernelArgs,{output:function(){},input:device.memoryTransaction.bind(device,"get"),});const program={sourceLines:kernel.sourceLines,sourceLineHeight:sourceLineHeight,statements:kernel.statements,kernelArgs:kernelArgs,};if(kernel.sourceLines.length-2!==kernel.statements.length){console.error("WARNING: Inconsistent kernel source line count when compared to callable statements, expected "+(kernel.statements.length)+" source lines but got "+(kernel.sourceLines.length-2));}
device.setProgram(grid,program);device.setKernelHighlighting(highlightKernelLines==="on");for(let msgID of["SMMessages","memoryMessages","sourceMessages"]){const element=document.getElementById(msgID);const messages=kernel[msgID];if(typeof messages!=="undefined"){element.innerHTML=messages.join("\n\n");element.hidden=false;}else{element.innerHTML='';element.hidden=true;}}
const memoryCanvasContainer=document.getElementById("memoryCanvasContainer");const canvasWidth=kernel.memory.input.columns*(CONFIG.memory.slotPadding+memorySlotSize);let canvasHeight=kernel.memory.input.rows*(CONFIG.memory.slotPadding+memorySlotSize);if(typeof kernel.memory.extraRowPadding!=="undefined"){canvasHeight+=kernel.memory.extraRowPadding.amount-CONFIG.memory.slotPadding;}
resetSize(memoryCanvasInput,canvasWidth,canvasHeight);resetSize(memoryCanvasContainer,canvasWidth,memoryCanvasContainer.height+canvasHeight);}
function clear(canvas,type){const ctx=canvas.getContext("2d");ctx.fillStyle='rgba(255, 255, 255, '+((type==="hard")?1.0:0.7)+')';ctx.fillRect(0,0,canvas.width,canvas.height);}
function cancelDraw(){window.cancelAnimationFrame(prevRenderFrameID);}
function queueDraw(){prevRenderFrameID=window.requestAnimationFrame(draw);}
function draw(now){clear(memoryCanvasInput,"hard");clear(kernelCanvas);device.step();if(device.programTerminated()){device.clear();clear(memoryCanvasInput,"hard");device.step();clear(kernelCanvas,"hard");drawing=false;}
if(drawing){queueDraw();}}
function restart(){drawing=false;cancelDraw();initSimulation();drawing=true;queueDraw();}
function pause(){drawing=!drawing;if(drawing){queueDraw();}}
document.addEventListener("DOMContentLoaded",_=>{initUI();restart();});